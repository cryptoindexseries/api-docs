# Authentication

In order use the APIs documented here you need to generate a **API Key ID** and **API Key Secret**. There are two 
types of requests this documentation explains; public data APIs and private user data APIs. For accessing public data APIs
only **API Key ID** is required. For private user data APIs a signature should be generated using **API Key Secret**. 

For all requests **API Key ID** should be included in Authorization header in Bearer format. E.g.

```
GET /ExamplePublicRequest
Headers:
  - Authorization: Bearer my-api-key-id
```

In addition to that for private user data APIs a **signature** from **current timestamp (in seconds precision)** should be generated and both 
signature and timestamp should be put as a query parameter to every request. E.g.

``` 
GET /ExamplePrivateRequest?timestamp=1625609684&sign=my-signature
Headers:
   - Authorization: Bearer my-api-key-id
```

Signature should be generated by using HMAC SHA256. The HMAC SHA256 signature is a keyed HMAC SHA256 operation.
Use your **API Key Secret** as the key and **timestamp** query parameter as the value for the HMAC operation.

An example in NodeJS using [CryptoJS](https://www.npmjs.com/package/crypto-js) library for generating signatures

```node
const apiSecret = "2028c72a-2bd3-4b0d-9e0e-1c9b5d4274df";
const timestamp = 1625609684
let query = 'timestamp=' + timestamp
const sign = CryptoJS.HmacSHA256(query, apiSecret).toString(CryptoJS.enc.Hex);
console.log(sign)
>> bccfa3ff9fbdfaf48426d689dcaa23b5874ffbbf17acfa887036ff5d26461831
```

Some additional warnings and constraints;
* Timestamp should be in seconds precision
* If signature is generated from a timestamp that is older than 1 minute, the request is rejected
* Authentication information is cached for 1 minute
* Please do not share your API Secret Key and If you think your key is exposed somehow please recreate it.


# Websocket API 

In this part, you can find the details of consuming data from our realtime websocket feed.

Our servers are implemented using [Socket.IO](https://socket.io/) library (Version 4.14). In order take advantage of its ease of use and features like
automatic reconnection using a socket.io client is highly recommended. But you can find details of connecting with bare WebSocket implementation.

WebSocket Location: wss://socket.dev.cryptoindexseries.com 

Some definitions that are useful for rest of the documentation;

**Symbol**: An instrument that includes base, quote currencies with exchange information.
```
BTC-USDT.BNB -> BTC-USDT pair from Binance 
BTC-USDT.CISCALC -> BTC-USDT pair that we (Crypto Indexx Series) calculated from various exchanges
BTC-USDT.CBS -> BTC-USDT pair from CoinBasePro
.... 
```

**Type of feed**: Indicates the type of data you want to receive for a symbol. Possible values are TICKER and TRADE. When concatenated
with symbol it defines the data that you will receive from WebSocket feed. 
```
BTC-USDT.BNB~TICKER -> Ticker data of BTC-USDT from Binance
BTC-USDT.BNB~TRADE -> Trades of BTC-USDT from Binance
....
```

**Action**: Indicates either `subscribe` or `unsubscribe` actions. When you subscribe to feed of an instrument you start receiving updates
for that instrument. When you unsubscribe from an instrument you stop receiving updates from an instrument.

## Authentication 

WebSocket API expects your **API Key ID** as query parameter with name **token**. E.g

wss://socket.dev.cryptoindexseries.com?token=my-api-key-id

## Subscription

In order to receive updates for an instrument first you need to subscribe to an instrument pair. We are expecting a message similar to this 

```node
{
    "action" : "subscribe", // Our action is subscription
    "symbols": ["BTC-USDT.BNB~TICKER"] // Multiple instrument can be add here
}
```

When you send such a message you will first receive and acknowledgement message:
```
OK|SUB|BTC-USDT.BNB~TICKER
```
Then you will get a snapshot message similar to the following;

```

{
  "p": {
    // Payload 
  },
  "ns": "BNB_BTCUSDT", // Native symbol of the instrument prefixed with exchangeCode_
  "d": "TICKER", // Type of data feed
  "seqnum": 6854283, // Sequence number to keep track of updates
  "u_ts": 1625613863270, // Time of broadcast
  "mt": "snapshot", // Message type 
  "s": "BTC-USDT.BNB" // CryptoIndexSeries symbol 
}
```

After receiving the snapshot whenever and update occurs on instrument it will be published to your feed. 

In order keep our Websocket API efficient we are only publishing changed fields, you will only get snapshot when you first send subscription request
to WebSocket API. Then you will start getting updates which will only include changed fields. Depending on your needs, you are expected to keep a live snapshot
in your client. Integrity of your live snapshot can be checked using sequence numbers (seqnum), in any case if you miss some messages you can send subscription request 
again to get a full snapshot.

An example scenario would be;
```
// First message (Snapshot)
{
    "p" {
        "lst": 10000
        "v" : 100000000000000
    },
    seqnum: 123
    mt: "snaphot"
}

// First update (Valid Seqnum)
{
    "p" {
        "lst": 10002 // Volume did not change, only latest price changed
    },
    seqnum: 124
    mt: "update"
}

// Second update (Invalid Seqnum) 
{
    "p" {
        "lst": 100034 // Volume did not change, only latest price changed
    },
    seqnum: 126 // This means you missed update 125 
    mt: "update"
}

// In this case you need to send subscribe request again to get full snapshot
```

## Unsubscription
To unsubscribe from an instrument WebSocket API expects a message like the following;

```node
{
    "action" : "unsubscribe", // Our action is un-subscription
    "symbols": ["BTC-USDT.BNB~TICKER"] // Multiple instrument can be add here
}
```

When you send such a message you will first receive and acknowledgement message:
```
OK|UNSUB|BTC-USDT.BNB~TICKER
```

## (Example) Connecting Using Socket.IO Client

```node
const options = {
    path: "/", 
    transports: ['websocket'],
    query: {
        token: "my-public-api-token"
    }
};

// Create socket connection 
const socket = io("wss://socket.dev.cryptoindexseries.com", options);

/**
 * Handler for handling messages from realtime feed
 * @param message
 */
function handleMesasge(message) {
    // Do something with message
}


/**
 * Subscribe to a instrument
 *
 * @param data E.g. List of symbols to subscribe
 */
function subscribe(data) {
    // Send subscribe message
    socket.emit('m', {action: 'subscribe', data: data});
    // Bind handler function (m here a channel in socket.io, out of context)
    socket.on("m", handleMesasge);
}

/**
 * Unsubscribe from instrument(s)
 *
 * @param List of instrument(s) to unsubscribe
 */
function unsubscribe(instruments) {
    socket.emit('m', {action: 'unsubscribe', data: instruments});
}


```

## (Example) Connecting Using Bare WebSockets

```node

// WS library used here mimic native browser WebSockets
const WebSocket = require('ws');
// Craete connection (with additional parameters)
const socket = new WebSocket("wss://socket.dev.cryptoindexseries.com?transport=websocket&EIO=4&token=my-public-api-token");

/**
 * Handler for handling messages from realtime feed
 * @param message
 */
function handleMesasge(message) {
    // Do something with message
}

/**
 * Subscribe to a instrument
 *
 * @param insturments List of symbols to subscribe
 */
function subscribe(insturments) {
    // First encode message
    const encoded = decodeMessage({action: 'subscribe', data: insturments})
    // Send subscribe message
    socket.send(encoded)
}

/**
 * Unsubscribe from instrument(s)
 *
 * @param insturments List of instrument(s) to unsubscribe
 */
function unsubscribe(instruments) {
    // First encode message
    const encoded = decodeMessage({action: 'subscribe', data: insturments})
    // Send unsubscribe message
    socket.send(encoded);
}

/**
 * Encode mesage so socket.io can understand
 * @param data
 */
function encodeMessage(data) {
    // This should be like 42["m",{...subscribe/unsubscribe action data...}]
    return `42["m",` + JSON.stringify(data) +`]`
}

/**
 * Decode message so socket.io can understand
 * @param data
 */
function decodeMessage(data) {
    // These are reqular messages with that requries simple encoding/decoding
    // This is like 42["m", "{....message data...}"]
    const sliced = message.data.slice(2, message.data.length);
    const json = JSON.parse(sliced);
    const payload = json[1];
    return payload; // Realtime feed message
}

// Socket message handler 
socket.onmessage = function handler(message) {
    if (message.data.startsWith(0)) {
        // There is an initialization process due to socket.io protocol this must
        // be completed before subscription events 
        socket.send("40");
    } else if (message.data.startsWith(2)) { 
        // 2 indicates ping message you need to send pong (3) whenever ping recieved
        // If you don't your connection will closed.
        socket.send("3");
    } else if (message.data.startsWith(42)) { 
        // These are reqular messages with that requries simple encoding/decoding
        const message = decodeMessage(message.data);
        handleRealtime(message);
    }   
}
```





